Feign Client란❓
스프링 환경에서 간편하게 외부 api를 호출할 수 있는 라이브러리.
넷플릭스에서 만들어졌다

RestTemplate랑 같은거 아님?🤔
feign client는 interface만 만들고 어노테이션을 추가하면 바로 사용할 수 있고, ErrorDecoder를 구현할 수 있다는 장점을 가지고 있다.

restTemplate도 feign과 마찬가지로 Http 통신을 쉽게 할 수 있는 템플인데, 코드를 직접 보면 둘의 확연한 차이가 느껴질 것이다.

RestTemplate
@RequiredArgsConstructor
@Service
public class RestTemplateExample {
    private final RestTemplate restTemplate = new RestTemplate();
    private final String CLIENT_ID = "클라이언트ID";
    private final String CLIENT_SECRET = "클라이언트 secret";

    public Dto requestBook(String keyword) {
        final HttpHeaders headers = new HttpHeaders();
        URI uri = UriComponentsBuilder
                .fromUriString("https://openapi.naver.com/v1/search/book.json")
                .queryParam("query", keyword)
                .encode()
                .build()
                .toUri();
        headers.set("X-Naver-Client-Id", CLIENT_ID);
        headers.set("X-Naver-Client-Secret", CLIENT_SECRET);

        final HttpEntity<String> entity = new HttpEntity<>(headers);
        return restTemplate.exchange(uri, HttpMethod.GET, entity, Dto.class).getBody();
    }
}
Feign
@RequiredArgsConstructor
@FeignClient(url = "https://openapi.naver.com/v1/search/book.json")
public interface FeignExample {

    private final String CLIENT_ID = "클라이언트ID";
    private final String CLIENT_SECRET = "클라이언트 secret";

    @GetMapping
    public Dto getBook(@RequestHeader("X-Naver-Client-Id")String client_id,
                       @RequestHeader("X-Naver-Client-Secret") String secret,
                       @RequestParam("query")String keyword);
}
코드가 훨씬 축소된 것을 볼 수 있다.

작동원리

위 사진처럼 feign이 매핑된 url로 요청을 받으면, 통신할 url에 정해진 메소드로 요청을 보낸 뒤, 결과값을 반환하게 된다.

정리
feign은 HTTP통신에 매우 편리한 라이브러리다. 소셜 로그인(oauth)과정에서 간편히 사용할 수도 있고, 이외의 다른 api 서버의 통신이 필요할 때 편리하게 사용할 수 있다

### 원본
https://velog.io/@lilseongwon/feign%EC%9D%80-%EB%B3%B4%EA%B3%A0-%EA%B0%80%EC%95%BC%EC%A7%80-%EB%AD%90%EA%B0%80-%EA%B7%B8%EB%A0%87%EA%B2%8C-%EA%B8%89%ED%95%B4
(본인 벨로그)
