# 브라우저란?

웹 서버와 통신하여 인터넷 사이트 및 다양한 컨텐츠를 볼 수 있도록 지원해주는 소프트웨어 프로그램이다

### 브라우저의 구조

인터넷 브라우저는 chrome, safari 등 여러 종류가 있는데 전체 구조는 아래와 동일하다
![image](https://user-images.githubusercontent.com/102791105/198884242-b1c9f710-7c13-49e9-ba27-c53dd5bf9ce4.png)

**사용자 인터페이스(UI)**

- 페이지를 보여주는 창을 제외한 나머지 모든 영역
    
    ex) 주소 표시줄, 이전/이후 버튼, 홈버튼, 북마크 버튼 등
    

**브라우저 엔진 / 레이아웃 엔진**

- UI와 렌더링 엔진 사이의 동작을 제어
- UI를 그리는 UI스레드, 네트워크 통신을 위한 네트워크 스레드, 파일에 접근하기 위한 스토리지 스레드 등

**렌더링 엔진**

- 브라우저 엔진과 밀접한 엔진으로, 웹 페이지가 표시되는 모든 영역을 제어
- 요청한 콘텐츠(HTML, CSS 등)을 파싱하고, 화면에 나타내는 일 수행

**자료 저장소 / 데이터 저장소**

- 자료(쿠키, localStorage, IndexedDB 같이 로컬에 저장되어 좀 더 오래 유지되어야 하는 데이터들을 보관할 수 있도록 지원하는 영역)

**통신 (Networking)**

- HTTP/HTTPS 네트워크 처리
- 플랫폼과 독립적인 인터페이스로, 각 플랫폼의 하부에서 실행

**자바스크립트 해석기(JS Interpreter) / 자바스크립트 엔진**

- 스크립트(JS 코드)를 파싱할 때 사용하는 JS 엔진
- HTML 파싱 중 scrpit 태그를 만나면, JS엔진이 제어 권한을 넘겨받음
    - 이 작업은 동기적으로 진행(JS 엔진이 작업을 마칠 때까지 HTML에서 진행 중인 과정은 잠시 중지)

**UI 백엔드 (UI Backend)**

- 기본 위젯을 그릴 때 이용
- OS의 방법 사용

모던 브라우저는 각각의 탭을 **독립적으로 처리**하여 높은 보안성과 더 좋은 사용성을 제공할 수 있다

## DOM 트리

DOM 트리는 ‘문서 객체 모델(Document Object Model)의 줄임말로, 객체로 표현된 HTML 문서이다

브라우저는 HTML 텍스트 문서를 바로 읽을 수 없기 때문에, 이를 객체의 형태로 바꾸어 브라우저가 읽을 수 있는 트리 구조로 변환한 것이 DOM 트리이다

DOM 트리 내 하나의 객체는 **노드**라 부르며, DOM 트리는 총 4가지 노드로 구성되어 있다

- 문서 노드(Document Node) : 트리의 최상위 객체, DOM 트리에 접근하기 위한 시작점
- 요소 노드(Element Node) : HTML 요소 (태그) 를 객체로 표현한 것
- 어트리뷰트 노드(Attribute Node) : HTML 요소의 ‘Attribute’를 객체로 표현한 것
- 텍스트 노드(Text Node) : HTML 요소의 ‘텍스트’를 객체로 표현한 것
![image](https://user-images.githubusercontent.com/102791105/198884274-f67ffd47-d22f-4293-a5cd-675ad28ee3f6.png)

외부에서 특정 노드에 접근하기 위해 DOM을 확인해야 할 때

 DOM 트리는 최상위 노드인 ‘문서 노드’ 부터 아래 방향으로 순차적으로 탐색된다

자바스크립트를 통해 HTML 문서에 접근할 때, 혹은 페이지를 조작하는 이벤트가 발생할 때 이 과정이 일어난다

그리고 DOM 트리 생성과정에서 브라우저는 HTML 문서의 에러들을 자동으로 처리한다

# 주소 창에 naver.com을 치면 생기는 일

이 과정은 아래 그림처럼 총 3단계로 구분할 수 있다
![image](https://user-images.githubusercontent.com/102791105/198884283-ed084442-ad04-44a8-97c5-3ee8f9752d14.png)

### 1. 주소창에 입력한 텍스트 정보 확인

대부분의 인터넷 브라우저는 자사의 주소창을 검색창과 동일하게 사용하고 있다

브라우저는 사용자가 주소창에 어떤 텍스트를 입력했을 때, 이 텍스트가 **검색어**인지 **URL**인지 확인한다

- **검색어라면**
    
    검색 엔진의 URL에 검색어를 포함한 주소로 페이지를 이동
    
- **URL이면**
    
    브라우저 엔진에서(네트워크 스레드를 통해) 네트워크 호출을 수행한다
    

따라서 주소창에 `naver.com`을 입력할 경우 브라우저는 네트워크 호출을 수행한다
![image](https://user-images.githubusercontent.com/102791105/198884291-44eaf55b-7dad-434b-9af1-ab96c2863010.png)

### 2. 네트워크 호출

**브라우저가 네트워크 호출을 하는 이유**

브라우저가 사용자에게 ‘네이버’라는 사이트를 화면에 보여주려면 깃허브의 HTML문서, CSS 문서, 스크립트, 이미지 등의 데이터를 미리 가지고 있어야 한다

하지만 이러한 정보는 브라우저가 아닌, 네이버 서버 컴퓨터에 존재하기 때문에 브라우저는 네이버 서버와의 네트워크 통신을 통해 이러한 데이터들을 가져와야 한다

이 작업을 수행하기 위해 브라우저는 네이버 서버 컴퓨터의 IP 주소를 알아야 한다. 따라서 네트워크 호출 과정은 2가지로 나뉜다

1. **네이버 서버의 주소를 찾는 과정**
    
    네이버 서버의 주소를 알아내기 위해, 클라이언트는 다음 과정을 수행한다
    
    > 자신의 host 파일에서 도메인 네임(`naver.com`)에 대응하는 IP 주소가 있는지 우선적으로 확인하고, 없다면 네임 서버에 네이버의 IP주소를 물어보는 요청을 보낸다
    > 
    
    여기서 도메인 네임은 URL `www.naver.com`에서 `naver.com`에 해당한다
    
    인터넷은 IP 주소를 기반으로 동작하지만, 우리가 인터넷을 사용할 때는 IP 주소 대신 사용하기 쉬운 문자로 이루어진 도메인 네임을 사용한다
    
    따라서 도메인 네임을 IP 주소로 변환해 주는 환경인 DNS(Domain Name System)가 반드시 필요한데, 이 DNS를 운영하는 장치를 네임 서버 또는 DNS 서버라고 한다. 즉, 네임 서버는 도메인 주소에 대응하는 IP주소를 찾아준다
    
    클라이언트는 일반적으로 네임 서버의 IP 주소를 이미 가지고 있어서 네임 서버와 통신이 가능하고, `naver.com`에 해당하는 IP 주소를 요청/응답 받을 수 있다     
    
                                                                   
    
2. **네이버 서버와 통신하여 필요한 데이터를 받는 과정**
    
    이제 클라이언트는 깃허브 서버의 IP를 알아서 깃허브 서버와 통신 가능하다. 클라이언트의 브라 우저는 (TCP 소켓을 열고 이를 통해) 네이버 서버에 데이터를 요청하는 HTTP Request를 보낸다.
    
    HTTP Request를 받은 네이버 서버는 클라이언트가 요청한 문서를 찾아 읽고, 이를 바이트 형태(1과 0)로 변환한 후, 클라이언트로 HTTP Response를 보낸다
    
![image](https://user-images.githubusercontent.com/102791105/198884306-398aca84-a5cc-4239-8e3b-fcf55b8c0a1f.png)
    

### 3. 렌더링

브라우저 엔진(의 네트워크 스레드)은 네이버 서버로부터 응답받은 데이터에 악성 바이러스 유무를 검사한다. 이 데이터는 바이트 형태의 텍스트 문서이므로, 브라우저 엔진이 읽을 수 없기 때문애 브라우저 엔진(의 UI 스레드)은 렌더링 엔진에게 해당 데이터를 해석하고, 웹 페이지를 화면에 띄우라고 요청한다.

요청을 받은 렌더링 엔진은 받을 데이터를 바탕으로 **렌더링 프로세스**를 수행하고, 이 과정이 끝나면 브라우저 엔진에게 작업 완료를 알린다. 그리고 화면에 네이버 페이지가 보여진다

# 렌더링 프로세스

렌더링 엔진은 브라우저 엔진으로부터 요청받은 내용을 화면에 표시한다.
![image](https://user-images.githubusercontent.com/102791105/198884346-0f87882b-348d-4cda-94cd-d4f401871438.png)

렌더링 과정은 4가지 과정으로 이뤄진다

1. HTML을 파싱하여 DOM트리 구축 CS를 파싱하여 CSSOM 트리 구축 (+JS 파싱)
2. DOM 트리와 CSSOM 트리를 통해 렌더 트리 구축 (Attachment / 형상 구축)
3. 렌더 트리 배치(Layout / Reflow)
4. 렌더 트리 그리기(Paint)

**웹 브라우저 별 사용하는 렌더링 엔진**

- 파이어폭스는 모질라에서 직접 만든 **게코(Gecko)** 엔진을 사용하고, 사파리는 **웹킷(Webkit)** 엔진을 사용
- 크롬은 웹킷(Webkit) 엔진을 사용했다가, 웹킷을 Fork하여 자체적으로 구현한 **블링크(Blink)** 엔진을 현재 사용
![image](https://user-images.githubusercontent.com/102791105/198884374-e83b9842-226d-4cb0-860b-b0cf9f5deee8.png)

웹킷(+Blink)의 렌더링 프로세스 과정
![image](https://user-images.githubusercontent.com/102791105/198884393-d4d5246f-ce7e-4634-9272-b6f6990b4539.png)

게코의 렌더링 프로세스 과정

## 파싱 (Parsing) 이란?

브라우저는 HTML, CSS 등의 딘순한 텍스트 문서를 이해하지 못하므로 이 문서를 브라우저가 이해할 수 있는 구조로 변환해주는 과정

파싱은 ‘어휘 분석’ 과 ‘구문 분석’ 두 가지 과정으로 구분할 수 있다

1. 어휘 분석(어휘 분석기) : 문자열을 의미 있는 작은 단위인 토큰으로 분해하는 과정
2. 구문 분석(파서) : 문자열의 문법에 따라 토큰 간의 위계관계를 분석하여 parsing 트리를 생성하는 과정

> 파싱 결과 생성되는 트리 형태를 parse 트리, parsing 트리, concrete syntax 트리 등 다양한 용어로 부른다
> 

> parse 트리는 토큰화 된 문자열의 단순한 트리에 불과하므로, 이를 사용하기 위해 브라우저는 parse 트리를 DOM 트리로 바꿔서 사용한다
> 
![image](https://user-images.githubusercontent.com/102791105/198884565-bf1b96d0-f6f9-40a5-82f8-6773908a9902.png)

### **1-1. HTML 파싱 → DOM 트리 생성**

렌더링 엔진이 HTML 문서를 수신받으면, HTML 파서는 이를 위에서부터 읽어 내리며 파싱을 진행하고, 그 결과물로 DOM 트리를 생성한다

**HTML 파싱 과정**

1. 서버에서 바이트 형태의 HTML 문서를 응답받는다
2. 지정된 인코딩 방식(UTF-8)에 따라 이를 문자열로 변환한다.

`<meta charset="UTF-8">`

1. 변환된 문자열을 **토큰**으로 분해한다
2. 토큰을 내용에 따라 **객체(노드)**로 변환한다
3. 객체를 **트리 구조**로 구성하여 **DOM**을 생성한다

사용자의 만족도를 높이기 위해 렌더링 엔진은 HTML 문서가 모두 파싱될 때까지 기다리지 않고, 파싱 이후의 과정인 배치와 그리기를 미리 진행한다

### 1-2. CSS 파싱 → CSSOM트리 생성

HTML 파싱 중 CSS문서를 가져오는 link 태그를 만나면, DOM 생성이 잠시 중단되고 해당 CSS의 파싱 과정이 시작된다

CSS 파서는 서버에서 수신받은 CSS 문서를 파싱하여 CSSOM 트리를 생성한다

참고로 CSS 파싱 과정은 기본적으로 HTML 파싱 과정과 동일하다

**CSS 파싱 과정**

1. 서버에서 바이트 형태의 CSS 문서를 응답받는다
2. 지정된 인코딩 방식(UTF-8)에 따라 이를 문자열로 변환한다

`<meta charset="UTF-8">`

1. 변환된 문자열을 토큰으로 분해한다
2. 토큰을 내용에 따라 객체(노드)로 변환한다
3. 객체를 트리 구조로 구성하여 CSSOM을 생성한다

CSSOM 트리의 노드는 DOM 트리 요소의 선택자에 맞춰 적용될 CSS 스타일 정보가 포함되어 있다.

### **1-3. JS 파싱**

HTML 파싱 과정에서 `script` 태그를 만나면, 렌더링 엔진은 DOM 생성을 잠시 중지하고 서버에서 해당 JS 리소스를 브라우저 엔진으로부터 받아온다. 그리고  JS엔진에게 제어권을 넘긴다.

JS 엔진은 받아온 JS 리소스를 파싱하여 AST(추상 구문 트리)를 생성하고 이를 바이트코드로 변환해 실행한다.

JS 파싱이 종료되면 렌더링 엔진은 다시 제어권을 돌려받고 DOM 생성을 이어나간다.

만약 `script`태그가 `body` 태그의 중간에 있으면 HTML 파싱이 끝나지 않은 상태에서 JS로 인해 DOM이 조작되어 에러가 발생할 위험이 생긴다. 따라서 script 태그는 반드시 `body`태그 내부의 **최하단**에 위치해야 한다

### 2. Render Tree 생성

![image](https://user-images.githubusercontent.com/102791105/198884596-9a1e4fe9-5ae8-43e8-9b8b-57135184ebad.png)
DOM + CSSOM = Render Tree

**렌더 트리 생성 과정**

1. `html` 태그와 `body` 태그를 처리하며 **렌더 트리 루트**를 구성한다
2. **DOM**의 최상위 노드부터 순회하면서 **화면에 보여지지 않는 노드**를 렌더 트리의 구성에서 제외한다
3. 화면에 보여지는 나머지 노드에 CSSOM 규칙을 찾아 일치하는 스타일을 적용한다

### 3. 레이아웃(Layout)
![image](https://user-images.githubusercontent.com/102791105/198884609-fcef3175-5280-48a8-9cbd-b14ccc41a8e6.png)

**렌더 트리의 노드들을 화면에 배치하는 과정**

노드의 위치는 (x, y) 좌표계 사용, 렌더 트리의 루트부터 아래로 내려가면서 계산 진행한다. 참고로 최상위 노드의 위치는 (0, 0)이며, CSS에서 상대적인 모든 값들은 절대적인 값인 `px` 단위로 변환된다.

레이아웃은 전체의 배치과정이 필요한 글로벌 레이아웃, 일부의 배치과정만 변경하는 로컬 레이아웃으로 구분한다.

**글로벌 레이아웃**

맨 처음에 레이아웃 발생 시, 초기 이후 창이 리사이즈 또는 font 등의 전역 스타일 변경 시 발생. 초기 배치 이후 레이아웃이 다시 일어나는 것을 리플로우 라고 한다.

반대로 로컬 레이아웃은 초기 배치 이후 일부 DOM 노드 변경 등 특정 부분에 재배치 필요시 발생, 이는 불필요한 낭비를 방지한다. 즉 로컬 레이아웃은 리플로우 발생 시 일어난다.

(로컬 레이아웃은 **더티 비트 (Dirty Bit) 방식**이라는 것을 통해 진행된다.)

### 4. 페인트(Paint)

레이아웃 과정에서 계산된 정보들로 각 노드를 화면에 그리는 페인트 과정이 진행된다. 페인트는 렌더 트리의 각 노드를 화면의 실제 픽셀로 변환해주는 작업이다. 픽셀로 변환하는 과정을 래스터화(Rasterizing)라고 한다.

페인트 과정 중 화면의 특정 위치에 여러 노드가 함께 그려질 경우, 여러 레이어를 만들고 이를 다시 합성하는 방식으로 작업이 이뤄진다

페인트 과정이 끝나면 브라우저 화면에 네이버 페이지가 보여진다
![image](https://user-images.githubusercontent.com/102791105/198884642-1b287283-851f-4e43-9e42-68cd60045828.png)

브라우저에 특정 변경이 생겨서 페인트 과정이 다시 일어나는 경우를 리페인트 라고 안다. 화면의 구조가 아닌 요소의 색깔이 변해도 리페인트가 일어난다.

= **브라우저는 변경 사항이 발생했을 때, 최소한의 작업만으로 동작하려 한다**

**출처** : https://velog.io/@sylagape1231/%EC%A3%BC%EC%86%8C%EC%B0%BD%EC%97%90-naver.com%EC%9D%84-%EC%B9%98%EB%A9%B4-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EC%9D%BC%EC%9D%84-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%B4%EB%B3%B4%EC%9E%90 
